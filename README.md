# Сравнение скорости JWT аутентификации при использовании SHA и UMAC.

 Проект по защите информации МФТИ 2022.  
   
- [Сравнение скорости JWT аутентификации при использовании SHA и UMAC](#сравнение-скорости-jwt-аутентификации-при-использовании-sha-и-umac)
  - [JSON Web Token](#json-web-token)
  - [RS256](#rs256)
  - [HS256](#hs256)
  - [UMAC](#umac)
  - [UHASH](#uhash)
    - [Универсальная функция](#универсальная-функция)
    - [L1-Hash — первый этап](#l1-hash--первый-этап)
    - [L2-Hash — второй этап](#l2-hash--второй-этап)
    - [L3-HASH — третий этап](#l3-hash--третий-этап)
  - [Настройка](#настройка)
  - [Проведение измерений](#проведение-измерений)
  - [Вывод](#вывод)
## JSON Web Token

JSON Web Token, сокращенно JWT.

Перед вами пример JWT-токена:
 ``eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c``
 
Он состоит из трех частей, разделенных точками:

`header` – заголовок  
`payload` – полезные данные  
`signature` – подпись.  

Фрагменты `header` и `payload` – это обычные JSON-строки, закодированные алгоритмом `base64` в последовательность `ASCII`-букв и цифр. А `signature` – это фрагмент шифрования строки `header.payload`, например, с помощью алгоритма HS256 с использованием секретного ключа:  
![image001](https://user-images.githubusercontent.com/31885817/208329577-a0dec3f5-a3cb-40bc-97b6-0164c56ecf40.jpg)  
`jwt_token = header.payload.signature`  

Обратите внимание, алгоритм `base64` не шифрует данные, а кодирует. Это означает, что данные в `JWT`-токенах не защищены от просмотра. Но, вот изменить данные в `header` или в `payload` не получится, так как подпись `signature` тогда будет некорректной и сервер «поймет», что данные в JWT-токене не соответствуют действительности. Это единственная защита, которая имеется в этих токенах. То есть, мы можем совершенно спокойно читать данные, но не менять.

Для расшифровки JWT существует сервис [jwt.io](https://jwt.io/#debugger-io).

## RS256

***RS256*** (подпись RSA с SHA-256) является асимметричным алгоритмом, и он использует пару открытого / закрытого ключа: поставщик имеет частный (секретный) ключ, используемый для создания подписи, и потребитель JWT получает открытый ключ для проверки подписи. Поскольку открытый ключ, в отличие от закрытого ключа, не нуждается в защите, большинство поставщиков удостоверений делают его легко доступным для потребителей для получения и использования (обычно через URL метаданные).

Является стандартным решением для JWT-аутентификации

## HS256

***HS256*** (HMAC С SHA-256) - это симметричный алгоритм, только с одним (секретным) ключом, который передается между двумя сторонами. Поскольку один и тот же ключ используется как для создания подписи, так и для ее проверки, необходимо позаботиться о том, чтобы ключ не был скомпрометирован.

Также является стандартым решением для JWT-аутентификации

## UMAC

Об алгоритме ***UMAC*** вы можете прочитать на [Википедии](https://ru.wikipedia.org/wiki/UMAC) или в учебном пособии [Криптографические методы
защиты информации](https://github.com/vlsergey/infosec).

Я опишу только UHASH

## UHASH

![Снимок экрана от 2022-12-20 03-24-16](https://user-images.githubusercontent.com/31885817/208553769-72baa0e8-e338-4a31-9770-db33255afa26.png)


***UHASH*** — универсальная функция хеширования, сердцевина алгоритма UMAC. UHASH — функция работает в три этапа. Сначала к входному сообщению применяется L1-HASH, потом к этому результату применяется L2-HASH и, наконец, к результату применяется L3-HASH . Если при этом длина входного сообщения не более 1024 бит, то L2-HASH не используется. Так как функция L3-Hash возвращает только слово длины 4 байта, то если требуется получить хеш длины больше 4 байт, осуществляется несколько итераций данной трехуровневой схемы.

### Универсальная функция
Пусть функция хеширования выбирается из класса хеш-функций H, которые отображают сообщения в D, набор всевозможных образов сообщения. Этот класс называется универсальным, если для каких-либо отдельных пар сообщений, существует на множестве H/D функций, функция, которая отображает их в элемент D. Смысл этой функции в том, что если третья сторона хочет заменить одно сообщение другим, но при этом считает, что хеш-функция была выбрана абсолютно случайно, то вероятность не обнаружения подмены принимающей стороной стремится к 1/D.

### L1-Hash — первый этап
***L1-Hash*** разбивает сообщения на куски из 1024 байт и к каждому куску применяет алгоритм хеширования называемый NH. Выходной результат алгоритма NH в 128 раз меньше входного.

### L2-Hash — второй этап
***L2-Hash*** работает с выходом L1-Hash, использует полиномиальный алгоритм POLY. Второй этап хеширования используется, только если длина входного сообщения больше 16 мегабайт. Использование алгоритма POLY требуется для того, чтобы избежать временную атаку. На выходе из алгоритма POLY получается 16 байтное число.

### L3-HASH — третий этап
Этот этап требуется для того чтобы из выходных 16 байтов алгоритма L2-Hash получить 4-байтное значение

## Настройка

Проект использует:  
* `Python 3.10.6`  
* `Django 4.1.4`
* `Django REST framework 3.14.0` 

Для запуска проекта необходимо:  
1. Подключить виртуальное окружение `venv/bin/python`
2. Выполнить команду `python drfsite/manage.py runserver`
3. Доступные URLs находятся в `drfsite/drfsite/urls.py`

## Проведение измерений

Сервер был развернут локально.
Проводились измерения времени ответы на запросы к сервису с использованием 2х разных хэш-функций.  
В таблице представлены среднее значения по 20 запросам.

|                       	| SHA, ms 	| UMAC-64, ms 	|
|----------------------:	|--------:	|------------:	|
|         /api/v1/token 	|     300 	|          63 	|
| /api/v1/token/refresh 	|       9 	|           3 	|
| /api/v1/token/women/9 	|      30 	|           8 	|

## Вывод
Данный эксперимент показал, что использование UHASH дает возможность увеличить скорость аутентификации в от 3 до 6 раз.
